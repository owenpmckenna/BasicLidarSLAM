use std::cmp::min;
use std::f32::consts::PI;
use serde::{Deserialize, Serialize};

fn angle_comp_rad(a: f32, b: f32) -> f32 {
    //min(abs(a-b), 360-abs(a-b)
    (a-b).abs().min((2.0*PI)-(a-b).abs())
}
fn angle_comp_deg(a: f32, b: f32) -> f32 {
    //min(abs(a-b), 360-abs(a-b)
    (a-b).abs().min(360.0-(a-b).abs())
}
//velocity is units per second!!!
//all angles and stuff in radians
//slope usually in radians
//x,y is meters i think
pub struct LidarLocalizer {
    pub pos: (f32, f32),
    pub heading: f32,
    pub vel: (f32, f32),
    pub ang_vel: f32,
    pub lines: Vec<Line>
}
impl LidarLocalizer {
    pub(crate) fn new() -> LidarLocalizer {
        LidarLocalizer {//blank at start
            pos: (0.0, 0.0),
            heading: 0.0,
            vel: (0.0, 0.0),
            ang_vel: 0.0,
            lines: vec![],
        }
    }
    pub fn clone_lines(&self, func: fn(f32) -> f32) -> Vec<Line> {
        self.lines.iter().map(|it| it.clone())
            .map(|mut it| {
                it.length = func(it.length);
                it.mid.0 = func(it.mid.0);
                it.mid.1 = func(it.mid.1);
                it.p0.0 = func(it.p0.0);
                it.p0.1 = func(it.p0.1);
                it.p1.0 = func(it.p1.0);
                it.p1.1 = func(it.p1.1);
                it
            })
            .collect()
    }
    pub fn process(&mut self, instant: InstantLidarLocalizer) {
        //TODO fully redo this method
        self.lines.clear();
        let mut tmp: Vec<Line> = instant.lines.into_iter().map(|x| x.into_line()).collect();
        self.lines.append(&mut tmp);
    }
}
#[derive(Serialize, Deserialize)]
#[derive(Clone, Copy)]
pub struct Line {
    pub mid: (f32, f32),
    pub slope: f32,
    pub length: f32,
    pub p0: (f32, f32),//debug values
    pub p1: (f32, f32)
}
fn slope(p0: (f32, f32), p1: (f32, f32)) -> f32 {
    (p1.1-p0.1)/(p1.0-p0.0)
}
fn dist(p0: (f32, f32), p1: (f32, f32)) -> f32 {
    ((p0.0-p1.0).powi(2) + (p0.1-p1.1).powi(2)).sqrt()
}
//WARNING: this code generated by chatgpt. if it starts producing insane data don't touch it.
fn distance_to_line(line_point: (f32, f32), slope: f32, new_point: (f32, f32)) -> f32 {
    let (x1, y1) = line_point;  // Point on the line
    let (x0, y0) = new_point;   // Point to find the distance to

    // Calculate the numerator: |m(x0 - x1) - (y0 - y1)|
    let numerator = (slope * (x0 - x1)) - (y0 - y1);

    // Calculate the denominator: sqrt(m^2 + 1)
    let denominator = (slope.powi(2) + 1.0).sqrt();

    // Return the absolute value of the numerator divided by the denominator
    numerator.abs() / denominator
}
trait Reducible where Self: Sized {
    fn best(a: &Self, b: &Self) -> bool;//true = first best, false = second best
    fn are_equivalent(&self, o: &Self) -> bool;
}
struct InstantLine {
    points: Vec<(f32, f32)>,
    known_avg_slope: f32
}
impl Reducible for InstantLine {
    fn best(a: &InstantLine, b: &InstantLine) -> bool {
        if a.points.len() > b.points.len() {
            true
        } else {
            false
        }
    }
    fn are_equivalent(&self, other: &InstantLine) -> bool {
        let find = self.points.iter().enumerate().find_map(|(i, it)| {
            let x = other.points.iter().enumerate().find(|(_i2, it2)| it.eq(it2));
            match x {
                None => { None }
                Some((i2, it2)) => { Some((i, i2)) }
            }
        });
        match find {
            None => { false }
            Some(_) => { true },
        }
    }
}
impl InstantLine {
    fn mid_point(&self) -> (f32, f32) {
        let mut avg_x = 0.0;
        let mut avg_y = 0.0;
        for point in &self.points {
            avg_x += point.0;
            avg_y += point.1;
        }
        avg_x = avg_x / (self.points.len() as f32);
        avg_y = avg_y / (self.points.len() as f32);
        (avg_x, avg_y)
    }
    fn into_line(self) -> Line {
        let mid = self.mid_point();
        let slope = slope(self.points[0], *self.points.last().unwrap());
        let length = dist(self.points[0], *self.points.last().unwrap());
        Line {mid, slope, length, p0: self.points[0], p1: *self.points.last().unwrap()}
    }
    fn avg_point_dist_from_center(&self) -> f32 {
        let mid = self.mid_point();
        let slope = self.self_avg_slope();
        self.points.iter().map(|it| distance_to_line(mid, slope, *it)).sum::<f32>() / self.points.len() as f32
    }
    pub fn self_avg_slope(&self) -> f32 {
        Self::avg_slope(self.points.as_slice())
    }
    //this is in radians because im an idiot
    fn avg_slope(points: &[(f32, f32)]) -> f32 {
        let sum: f32 = points
            .windows(2)
            .map(|w| {
                let dx = w[1].0 - w[0].0;
                let dy = w[1].1 - w[0].1;
                dy.atan2(dx)
            })
            .sum();
        sum / (points.len()-1) as f32
    }
    //this returns the avg amount that each pair of points' slope (in radians) is different from the avg slope
    fn compare_avg_slope(points: &[(f32, f32)], avg_slope: f32) -> f32 {
        let sum: f32 = points
            .windows(2)
            .map(|w| {
                let dx = w[1].0 - w[0].0;
                let dy = w[1].1 - w[0].1;
                angle_comp_rad(dy.atan2(dx), avg_slope)
            })
            .sum();
        sum / (points.len()-1) as f32
    }
    const ALLOWED_INIT_AVG_POINT_DISTANCE: f32 = 0.050;//50 cm
    pub const INIT_LINE_POINTS: usize = 7;
    fn is_line(p: [(f32, f32); Self::INIT_LINE_POINTS]) -> Option<InstantLine> {
        //let mut slopes = [0f32; Self::INIT_LINE_POINTS-1];//must be 1 less than p.len()
        let avg = Self::compare_avg_slope(&p, Self::avg_slope(&p));
        let avg_dist = dist(p[0], *p.last().unwrap()) / p.len() as f32;
        let yes = avg.abs() < (Self::WITHIN_DEGREES / 180.0 * PI) && avg_dist < Self::ALLOWED_INIT_AVG_POINT_DISTANCE;
        if !yes {
            return None
        }
        Some(InstantLine {points: p.to_vec(), known_avg_slope: avg})
    }
    const WITHIN_DEGREES: f32 = 12.5;
    const POINT_DISTANCE: f32 = 0.1;//100 cm. dist between the closest point in list and our new point
    const STRAIGHTNESS: f32 = 0.01;//10 cm. this is now far new points can be from the line between the first and last point
    fn should_add(&mut self, p: &(f32, f32), left: bool) -> bool {
        //NOTE: slopes always left to right. Assume points sorted.
        let near_point = if left { self.points[0] } else { *self.points.last().unwrap() };//closest point
        let far_point = if !left { self.points[0] } else { *self.points.last().unwrap() };//farthest away point
        let new_slope = (if left {slope(*p, far_point)} else {slope(far_point, *p)}).atan();//what slope will be if we accept in radians
        let old_slope = self.known_avg_slope;//"avg slope" of line so far
        let new_distance = dist(*p, near_point);//we will test if within 50 cm
        let dist_to_line = distance_to_line(near_point, old_slope, *p);//
        let to_add = angle_comp_rad(old_slope, new_slope) < (Self::WITHIN_DEGREES / 180.0 * PI) && new_distance < Self::POINT_DISTANCE && dist_to_line < Self::STRAIGHTNESS;
        if to_add {
            if left {
                self.points.insert(0, *p);
            } else {
                self.points.push(*p);
            }
            self.known_avg_slope = self.self_avg_slope();
        }
        to_add
    }
}
pub struct InstantLidarLocalizer {
    altered_point_list: Vec<(f32, f32)>,
    lines: Vec<InstantLine>
}
impl InstantLidarLocalizer {
    //velocity is x,y (estimate) current speed in units per second. time is millis since scan started
    pub fn new(vel: (f32, f32), time: f32, points: &Vec<(f32, f32)>) -> InstantLidarLocalizer {
        if points.len() < 10 {
            //empty
            return InstantLidarLocalizer { altered_point_list: vec![], lines: vec![] }
        }
        let size = points.len() as f32;
        let time = time / 1000.0; //fraction of a second the scan lasted
        let scan_vel = (vel.0 * time, vel.1 * time); //distance traveled during scan
        let altered_points: Vec<(f32, f32)> = points.iter().enumerate()
            //index -> fraction of list completed
            .map(|(i, it)| (i as f32 / size, it))
            .map(|(i, it)| (it.0 + (scan_vel.0 * i), it.1 + (scan_vel.1 * i)))
            .collect();
        let mut i = 2usize;
        let mut lines = Vec::new();
        while i < altered_points.len() - InstantLine::INIT_LINE_POINTS {
            let line = InstantLine::is_line(altered_points[i..i + InstantLine::INIT_LINE_POINTS].try_into().unwrap()); //test if consecutive points are in a line
            match line {
                Some(mut it) => {
                    let s = i;
                    //keep trying to add points until they don't "fit"
                    //i += 5;//because those points are in this line
                    //now we'll look for everything else in the line
                    for x in (i+InstantLine::INIT_LINE_POINTS)..altered_points.len() {
                        it.should_add(&altered_points[x], false);
                    }
                    for x in (0..s).rev() { //check all the others
                        //reversed because that will keep the line in order
                        it.should_add(&altered_points[x], true);
                    }
                    lines.push(it);
                }
                None => { /*ignore this*/ }
            }
            i += 1;
        }
        //should sort in ascending order of distances
        //lines.sort_by(|x, y| y.known_avg_slope.total_cmp(&x.known_avg_slope));
        //lines = lines.into_iter().filter(|it| {
        //    it.points.len() > (InstantLine::INIT_LINE_POINTS as f64 * 1.25) as usize
        //}).collect();
        lines.reduce();
        InstantLidarLocalizer { altered_point_list: altered_points, lines }
    }
}
trait Reduce<T> where Self: Sized, T: Reducible {
    fn reduce(&mut self);
}
impl Reduce<InstantLine> for Vec<InstantLine> {
    fn reduce(&mut self) {
        let mut len = self.len();
        for x in 0..len {
            if x >= len {//guard
                continue
            }
            let mut y = x + 1;
            while y < len {
                if self[x].are_equivalent(&self[y]) {
                    len -= 1;
                    if !InstantLine::best(&self[x], &self[y]) {
                        self.swap(x, y);
                    }
                    self.remove(y);
                } else {
                    y += 1;
                }
            }
        }
    }
}